<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Satellite Density Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#161922;
      --ink:#e7e9ee;
      --muted:#a8b0bf;
      --accent:#3aa0ff;
      --accent-2:#9b6cff;
      --chip:#1e2230;
      --grid:#2a2f3d;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    }
    header{
      padding:12px 16px; border-bottom:1px solid var(--grid);
      display:flex; gap:12px; align-items:center; justify-content:space-between;
    }
    header .title{font-weight:600}
    .wrap{
      display:grid; grid-template-columns: 340px 1fr;
      grid-template-rows: auto 1fr; height:calc(100vh - 58px);
    }
    aside{
      grid-row:1 / span 2; grid-column:1;
      border-right:1px solid var(--grid); background:var(--panel);
      display:flex; flex-direction:column; padding:12px; gap:12px; overflow:auto;
    }
    main{
      grid-column:2; grid-row:2; overflow:auto; padding:12px;
      display:grid; grid-template-rows: 0.8fr 1.2fr; gap:12px;
    }
    .card{
      background:var(--panel); border:1px solid var(--grid);
      border-radius:14px; padding:10px; box-shadow:0 0 0 1px rgba(255,255,255,0.02) inset;
    }
    .card h3{margin:0 0 8px 0; font-size:14px; color:var(--muted); font-weight:600}
    .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
    select, button, input[type="range"]{
      background:var(--chip); color:var(--ink); border:1px solid var(--grid);
      padding:8px 10px; border-radius:10px; outline:none;
    }
    select{min-width:160px}
    button{cursor:pointer}
    button.primary{background:var(--accent); color:#081019; border-color:transparent}
    .small{font-size:12px; color:var(--muted)}
    .stack{display:flex; flex-direction:column; gap:8px}
    .plots{
      display:grid; grid-template-columns: 1fr 1fr; gap:12px; height:100%;
    }
    #globe,#map{height:100%}
    #timeseries{height:100%}
    .legend-note{color:var(--muted); font-size:12px; margin-top:-4px}
    .spacer{flex:1}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    a, a:visited{color:var(--accent)}
  </style>
</head>
<body>
  <header>
    <div class="title">Satellite Density Dashboard</div>
    <div class="row small">
      <span id="status" class="mono">Loading…</span>
    </div>
  </header>

  <div class="wrap">
    <!-- Controls -->
    <aside>
      <div class="card stack">
        <h3>Playback</h3>
        <div class="row">
          <button id="play" class="primary">▶︎ Play</button>
          <button id="pause">⏸︎ Pause</button>
          <div class="spacer"></div>
          <label class="small">Speed</label>
          <select id="speed">
            <option>1x</option><option>2x</option><option>5x</option>
            <option>10x</option><option>25x</option><option>50x</option>
          </select>
        </div>
        <input id="slider" type="range" min="0" max="1" step="1" value="0"/>
        <div class="row small">
          <span>Time:</span><span id="tlabel" class="mono">—</span>
        </div>
      </div>

      <div class="card stack">
        <h3>Models & Satellites</h3>
        <div class="row">
          <label class="small">Time Series 1</label>
          <select id="modelA"></select>
        </div>
        <div class="row">
          <label class="small">Time Series 2</label>
          <select id="modelB"></select>
        </div>
        <div class="row">
          <label class="small"># Sats</label>
          <select id="satCount">
            <option>1</option><option>2</option><option>3</option>
            <option>6</option><option>9</option><option selected>18</option>
          </select>
        </div>
        <div class="legend-note">
          Density lines use per-satellite colors; bold lines show means.
        </div>
      </div>

      <div class="card stack">
        <h3>Notes</h3>
        <div class="small">
          - Built for GitHub Pages (static).<br/>
          - Uses <code class="mono">docs/dashboard_data.json</code>.<br/>
          - No external textures; robust and lightweight.
        </div>
      </div>
    </aside>

    <!-- Plots -->
    <main>
      <div class="plots">
        <div class="card"><h3>Inertial View</h3><div id="globe"></div></div>
        <div class="card"><h3>Lat / Lon Tracks</h3><div id="map"></div></div>
      </div>
      <div class="card">
        <h3>Density (top), Dst (middle), Kp (bottom)</h3>
        <div id="timeseries"></div>
      </div>
    </main>
  </div>

  <script>
  (async function(){
    /* ---------- Utilities ---------- */
    const $ = (id)=>document.getElementById(id);
    const status = $('status');

    // Color helpers
    const viridis = ['#440154','#482878','#3e4989','#31688e','#26828e','#1f9e89','#35b779','#6ece58','#b5de2b','#fde725'];
    function colorRamp(n, i){
      if(n<=1) return viridis[6];
      const idx = Math.round(i*(viridis.length-1)/(n-1));
      return viridis[Math.max(0,Math.min(viridis.length-1,idx))];
    }

    // log-scale Turbo-like simple ramp for markers (compact)
    function turbo(v, vmin, vmax){
      const t = Math.max(0, Math.min(1, (Math.log10(Math.max(v,1e-20)) - Math.log10(Math.max(vmin,1e-20))) /
                                      (Math.log10(Math.max(vmax,1e-19)) - Math.log10(Math.max(vmin,1e-20)))));
      const stops=[[34,136,234],[84,233,242],[120,255,104],[255,233,84],[255,140,54],[220,38,127]];
      const k = Math.min(stops.length-2, Math.floor(t*(stops.length-1)));
      const f = t*(stops.length-1)-k;
      const c = stops[k].map((v,j)=>Math.round(v + f*(stops[k+1][j]-v)));
      return `rgb(${c[0]},${c[1]},${c[2]})`;
    }

    // Unified palette for time series groups
    const COLOR_A_BASE = 'rgba(80,160,255,0.35)';   // blue translucent for series A per-sat
    const MEAN_A_COLOR = '#2b6cb0';                 // solid blue for series A mean
    const COLOR_B_BASE = 'rgba(255,100,100,0.28)';  // red translucent for series B per-sat
    const MEAN_B_COLOR = '#c53030';                 // solid red for series B mean
    const HASDM_COLOR  = '#e6e6e6';                 // neutral for HASDM model

    // Number of recent steps to show on lat/lon tracks
    const TAIL_STEPS = 10;

    /* ---------- Load data ---------- */
    // Load data with friendly error if opened via file://
    status.textContent = 'Loading data…';
    const cacheBuster = `?v=${Date.now()}`; // avoid CDN/browser caching on updates
    let dash;
    try {
      const resp = await fetch(`./dashboard_data.json${cacheBuster}`);
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
      }
      dash = await resp.json();
      status.textContent = 'Preparing…';
    } catch (err) {
      console.error('Failed to load dashboard_data.json', err);
      status.textContent = '⚠️ Could not load data. If you opened this file directly (file://), please serve docs/ over http(s) — e.g., `python -m http.server -d docs 8000` then visit http://localhost:8000/';
      return;
    }

    // Expected structure:
    // dash.combos: { "1": ["satA",...], "2": [...], ... }
    // dash.densities_by_model: { modelKey: { times:[], model:[], SAT1:[], ... } }
    // dash.trajectories: [{name, path:[[x,y,z],...], latlonalt:[[lat,lon,alt],...]}...]
    // dash.kp: [{datetime, kp}], dash.dst: [{datetime, dst}]
    const combos = dash.combos || {};
    const models = dash.densities_by_model || { commercial: dash.densities };
    const modelKeys = Object.keys(models);
    const satsAll = (()=>{
      const any = models[modelKeys[0]] || {};
      return Object.keys(any).filter(k=>!['times','model','mean'].includes(k));
    })();
    const trajArr = dash.trajectories || [];
    const kpArr = dash.kp || [];
    const dstArr = dash.dst || [];

    // Populate selectors
    const modelA = $('modelA'), modelB = $('modelB');
    modelKeys.forEach(k=>{
      const label = k.replace(/_/g,' ').replace(/\b\w/g, s=>s.toUpperCase());
      const o1 = document.createElement('option'); o1.value=k; o1.textContent=label; modelA.appendChild(o1);
      const o2 = document.createElement('option'); o2.value=k; o2.textContent=label; modelB.appendChild(o2);
    });
    // Default A: first key; Default B: none (empty option)
    const noneOpt = document.createElement('option'); noneOpt.value=''; noneOpt.textContent='None';
    modelB.insertBefore(noneOpt, modelB.firstChild);
    modelA.value = modelKeys.includes('commercial') ? 'commercial' : modelKeys[0];
    modelB.value = '';

    const satCountSel = $('satCount');
    let satCount = parseInt(satCountSel.value,10);

    // Time axis
    function parseTimes(arr){ return arr.map(t=>new Date(t)); }
    function getModel(key){
      if(!key) return null;
      const raw = models[key];
      if(!raw) return null;
      // For assimilated variants, multiply satellite series by 2.2 (missing scale factor)
      if(/^assimilated/i.test(key)){
        const out = { times: raw.times, model: raw.model };
        Object.keys(raw).forEach(k=>{
          if(!['times','model','mean'].includes(k)){
            // scale per-satellite series only
            out[k] = (raw[k] || []).map(v => v / 2.2);
          }
        });
        return out;
      }
      // Non-assimilated: return as-is
      return raw;
    }

    /* ---------- Shared time base ---------- */
    let modelAData = getModel(modelA.value);
    const timesAll = parseTimes(modelAData.times);
    const tMin = timesAll[0], tMax = timesAll[timesAll.length-1];

    // Slider time base derived from trajectories length if present, otherwise density times
    const nSteps = (trajArr[0] && trajArr[0].path) ? trajArr[0].path.length : timesAll.length;
    const trajStart = timesAll[0] || new Date();
    const trajTimes = Array.from({length:nSteps},(_,i)=> new Date(trajStart.getTime()+i*60*1000)); // 60s step fallback

    // Map helper
    const satIndex = Object.fromEntries(trajArr.map((s,i)=>[s.name, i]));

    // Active satellites by count using combos
    function activeSatNames(){
      const c = combos[String(satCount)] || combos[satCount] || [];
      return c.filter(n=>satsAll.includes(n));
    }

    // Mean helper
    function sliceToIdx(arr, idx){ return arr.slice(0, Math.max(1, idx+1)); }
    function meanSeries(dobj, names){
      const n = names.length, L = dobj.times.length;
      const out = new Array(L);
      for(let t=0;t<L;t++){
        let s = 0;
        for(const nm of names){ s += (dobj[nm]?.[t] ?? 0); }
        out[t] = s / Math.max(1,n);
      }
      return out;
    }

    // Index series to current time
    const kpTimes = kpArr.map(d=>new Date(d.datetime));
    const kpVals  = kpArr.map(d=>d.kp);
    const dstTimes= dstArr.map(d=>new Date(d.datetime));
    const dstVals = dstArr.map(d=>d.dst);

    /* ---------- Build plots ---------- */

    // 1) Inertial view (clean sphere + markers)
    (function initGlobe(){
      const R = 6378137; // meters
      const phi = [], th = [];
      for(let i=0;i<40;i++) phi.push(i*Math.PI/39);
      for(let j=0;j<80;j++) th.push(j*2*Math.PI/79);
      const xs = phi.map(p=>th.map(t=>R*Math.cos(t)*Math.sin(p)));
      const ys = phi.map(p=>th.map(t=>R*Math.sin(t)*Math.sin(p)));
      const zs = phi.map(p=>th.map(t=>R*Math.cos(p)));

      const earth = {
        type:'surface', x:xs, y:ys, z:zs, showscale:false, opacity:0.12,
        colorscale:[[0,'#6ab7ff'],[1,'#6ab7ff']], hoverinfo:'skip'
      };

      // Satellite marker traces (one per active sat). Start with placeholders; update via restyle.
      const names = activeSatNames();
      const markers = names.map((nm,i)=>({
        type:'scatter3d', mode:'markers',
        x:[0], y:[0], z:[0],
        marker:{size:5, color:viridis[i%viridis.length]},
        name:nm, showlegend:false, hoverinfo:'skip'
      }));

      const layout = {
        scene:{
          xaxis:{visible:false}, yaxis:{visible:false}, zaxis:{visible:false},
          aspectmode:'data', bgcolor:'rgba(0,0,0,0)'
        },
        margin:{t:0,l:0,r:0,b:0},
        paper_bgcolor:'rgba(0,0,0,0)',
        plot_bgcolor:'rgba(0,0,0,0)'
      };
      Plotly.newPlot('globe', [earth, ...markers], layout, {displaylogo:false, responsive:true});
    })();

    // 2) Lat/Lon map (tracks + current markers)
    function makeMapTraces(step){
      const names = activeSatNames();
      const traces = [];
      names.forEach((nm,i)=>{
        const idx = satIndex[nm];
        if(idx===undefined) return;
        const lla = trajArr[idx].latlonalt || [];
        const lon = lla.map(p=>p[1]);
        const lat = lla.map(p=>p[0]);

        // Track (line): only show last TAIL_STEPS
        const startIdx = Math.max(0, step - (TAIL_STEPS - 1));
        traces.push({
          type:'scattergeo', mode:'lines',
          lon: lon.slice(startIdx, step + 1),
          lat: lat.slice(startIdx, step + 1),
          line:{width:1, color: colorRamp(names.length, i)},
          name: nm, showlegend:false, hoverinfo:'skip'
        });
        // Current marker
        if(lla[step]){
          traces.push({
            type:'scattergeo', mode:'markers',
            lon:[lla[step][1]], lat:[lla[step][0]],
            marker:{size:6, color: colorRamp(names.length, i)},
            name: nm, showlegend:false, hovertemplate: `${nm}<extra></extra>`
          });
        }
      });
      return traces;
    }
    (function initMap(){
      const layout = {
        geo:{
          projection:{type:'natural earth'},
          showland:true, landcolor:'#1e2533',
          showcountries:true, countrycolor:'#47506a',
          showocean:true, oceancolor:'#0e3954',
          lataxis:{range:[-80,80]}, lonaxis:{range:[-180,180]},
          bgcolor:'rgba(0,0,0,0)'
        },
        margin:{t:0,l:0,r:0,b:0},
        paper_bgcolor:'rgba(0,0,0,0)',
        plot_bgcolor:'rgba(0,0,0,0)'
      };
      Plotly.newPlot('map', makeMapTraces(0), layout, {displaylogo:false, responsive:true});
    })();

    // 3) Time series (3 rows: Density, Dst, Kp step)
    function makeTimeseries(step){
      const names = activeSatNames();

      const A = getModel(modelA.value);
      const B = getModel(modelB.value);
      const times = A ? parseTimes(A.times) : [];

      // index into density times using current traj time
      const ct = trajTimes[step];
      let k=0; while(times.length && k<times.length-1 && ct>=times[k+1]) k++;

      const traces = [];

      // --- HASDM model line (from series A's model) ---
      if (A && Array.isArray(A.model)){
        traces.push({
          x: sliceToIdx(times,k), y: sliceToIdx(A.model,k),
          mode:'lines', name:'HASDM',
          line:{width:2, color: HASDM_COLOR},
          hovertemplate:'HASDM: %{y:.2e}<extra></extra>',
          xaxis:'x', yaxis:'y1'
        });
      }

      // --- Per-satellite lines for A (unified blue, translucent) ---
      if (A){
        names.forEach((nm)=>{
          if(!A[nm]) return;
          traces.push({
            x: sliceToIdx(times,k), y: sliceToIdx(A[nm],k),
            mode:'lines', name: nm, showlegend:false,
            line:{width:1.2, color: COLOR_A_BASE},
            hovertemplate:`${nm}: %{y:.2e}<extra></extra>`,
            xaxis:'x', yaxis:'y1'
          });
        });
        // Mean A (bold, darker blue)
        const meanA = meanSeries(A, names);
        traces.push({
          x: sliceToIdx(times,k), y: sliceToIdx(meanA,k),
          mode:'lines', name:'Mean (A)',
          line:{width:3, color: MEAN_A_COLOR},
          hovertemplate:'Mean (A): %{y:.2e}<extra></extra>',
          xaxis:'x', yaxis:'y1'
        });
      }

      // --- Per-satellite lines for B (optional, unified red) ---
      if (B){
        const timesB = parseTimes(B.times);
        let kb=0; while(timesB.length && kb<timesB.length-1 && ct>=timesB[kb+1]) kb++;
        names.forEach((nm)=>{
          if(!B[nm]) return;
          traces.push({
            x: sliceToIdx(timesB,kb), y: sliceToIdx(B[nm],kb),
            mode:'lines', name: nm+' (B)', showlegend:false,
            line:{width:1.2, color: COLOR_B_BASE},
            hovertemplate:`${nm} (B): %{y:.2e}<extra></extra>`,
            xaxis:'x', yaxis:'y1'
          });
        });
        const meanB = meanSeries(B, names);
        traces.push({
          x: sliceToIdx(timesB,kb), y: sliceToIdx(meanB,kb),
          mode:'lines', name:'Mean (B)',
          line:{width:3, color: MEAN_B_COLOR},
          hovertemplate:'Mean (B): %{y:.2e}<extra></extra>',
          xaxis:'x', yaxis:'y1'
        });
      }

      // --- Dst ---
      let kd=0; while(kd<dstTimes.length-1 && ct>=dstTimes[kd+1]) kd++;
      const dstTrace = {
        x: sliceToIdx(dstTimes,kd), y: sliceToIdx(dstVals,kd),
        mode:'lines+markers', name:'Dst', line:{width:2, color:'#7bd88f'},
        marker:{size:4}, xaxis:'x', yaxis:'y2', hovertemplate:'Dst: %{y}<extra></extra>'
      };

      // --- Kp (step-like) ---
      let kk=0; while(kk<kpTimes.length-1 && ct>=kpTimes[kk+1]) kk++;
      const kpTrace = {
        x: sliceToIdx(kpTimes,kk), y: sliceToIdx(kpVals,kk),
        mode:'lines', name:'Kp', line:{width:2, color:'#ffb86b', shape:'hv'},
        xaxis:'x', yaxis:'y3', hovertemplate:'Kp: %{y}<extra></extra>'
      };

      const layout = {
        grid:{rows:3, columns:1, pattern:'independent', roworder:'top to bottom'},
        xaxis:{
          title:'Time', type:'date', tickformat:'%b %d\n%H:%M', anchor:'y3', domain:[0,1],
          range:['2023-04-21T00:00:00Z','2023-04-28T00:00:00Z']
        },
        yaxis:{title:'Density (kg/m³)', tickformat:'.2e', domain:[0.56,1], rangemode:'tozero'},
        yaxis2:{title:'Dst (nT)', domain:[0.28,0.56]},
        yaxis3:{title:'Kp', dtick:3, domain:[0,0.28]},
        legend:{orientation:'h', y:-0.18, font:{color:'#d5d9e5'}},
        margin:{t:10,l:60,r:20,b:70},
        paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
        font:{color:'#e7e9ee'}, hovermode:'x unified'
      };

      Plotly.react('timeseries', [...traces, dstTrace, kpTrace], layout, {displaylogo:false, responsive:true});
    }

    // Initial render
    makeTimeseries(0);

    // Position updates (globe & map) + time label
    const densMin = 0.7e-13, densMax = 8e-13;
    function updateScene(step){
      // time label
      $('tlabel').textContent = trajTimes[step].toISOString().replace('T',' ').slice(0,19);

      // Globe: update satellite markers
      const names = activeSatNames();
      const updates = {x:[], y:[], z:[], 'marker.color':[]};
      const A = getModel(modelA.value);
      const times = parseTimes(A.times);
      // find density index for current time
      const ct = trajTimes[step];
      let k=0; while(k<times.length-1 && ct>=times[k+1]) k++;

      names.forEach((nm)=>{
        const i = satIndex[nm]; if(i===undefined) return;
        const pos = (trajArr[i].path?.[step]) || [0,0,0];
        updates.x.push([pos[0]]);
        updates.y.push([pos[1]]);
        updates.z.push([pos[2]]);
        const val = (A[nm]?.[k]) ?? 1e-13;
        updates['marker.color'].push([turbo(val, densMin, densMax)]);
      });
      // traces: 0 is earth surface, markers start at 1
      const idxs = Array.from({length:names.length},(_,j)=>1+j);
      Plotly.restyle('globe', updates, idxs);

      // Map
      Plotly.react('map', makeMapTraces(step), {
        geo:{
          projection:{type:'natural earth'}, showland:true, landcolor:'#1e2533',
          showcountries:true, countrycolor:'#47506a', showocean:true, oceancolor:'#0e3954',
          lataxis:{range:[-80,80]}, lonaxis:{range:[-180,180]}, bgcolor:'rgba(0,0,0,0)'
        },
        margin:{t:0,l:0,r:0,b:0}, paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)'
      }, {displaylogo:false, responsive:true});

      // Time series to current time
      makeTimeseries(step);
    }

    /* ---------- Controls ---------- */
    const slider = $('slider'); slider.max = String(nSteps-1); slider.value = '0';

    let playing = false, timer = null;
    function speedMs(){
      const s = $('speed').value;
      const mult = parseInt(s) || parseInt(s.replace('x','')) || 1;
      return Math.max(20, 400 / Math.max(1,mult));
    }

    function play(){
      if(playing) return;
      playing = true;
      timer = setInterval(()=>{
        let i = parseInt(slider.value,10);
        i = (i+1) % nSteps;
        slider.value = String(i);
        updateScene(i);
      }, speedMs());
    }
    function pause(){
      playing = false;
      if(timer){ clearInterval(timer); timer=null; }
    }

    $('play').onclick = ()=>{ pause(); play(); };
    $('pause').onclick = ()=>{ pause(); };
    $('speed').onchange = ()=>{ if(playing){ pause(); play(); } };
    slider.oninput = ()=>{ pause(); updateScene(parseInt(slider.value,10)); };

    satCountSel.onchange = ()=>{
      satCount = parseInt(satCountSel.value,10);
      // re-seed globe traces to match new satellite count
      // easiest: rebuild globe with new marker set
      (function resetGlobe(){
        const gd = document.getElementById('globe');
        const data = gd.data || [];
        const earth = data[0]; // keep surface
        const names = activeSatNames();
        const markers = names.map((nm,i)=>({
          type:'scatter3d', mode:'markers',
          x:[0], y:[0], z:[0],
          marker:{size:5, color:colorRamp(names.length,i)},
          name:nm, showlegend:false, hoverinfo:'skip'
        }));
        Plotly.react('globe', [earth, ...markers], gd.layout, {displaylogo:false, responsive:true});
      })();
      updateScene(parseInt(slider.value,10));
    };

    modelA.onchange = ()=>{
      modelAData = getModel(modelA.value);
      updateScene(parseInt(slider.value,10));
    };
    modelB.onchange = ()=>{
      updateScene(parseInt(slider.value,10));
    };

    // First paint
    status.textContent = `Ready · ${activeSatNames().length} sats`;
    updateScene(0);
  })();
  </script>
</body>
</html>