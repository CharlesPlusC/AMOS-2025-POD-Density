<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Satellite Density Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#161922;
      --ink:#e7e9ee;
      --muted:#a8b0bf;
      --accent:#3aa0ff;
      --accent-2:#9b6cff;
      --chip:#1e2230;
      --grid:#2a2f3d;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    }
    header{
      padding:12px 16px; border-bottom:1px solid var(--grid);
      display:flex; gap:12px; align-items:center; justify-content:space-between;
    }
    header .title{font-weight:600}
    .wrap{
      display:grid; grid-template-columns: 340px 1fr;
      grid-template-rows: auto 1fr; height:calc(100vh - 58px);
    }
    aside{
      grid-row:1 / span 2; grid-column:1;
      border-right:1px solid var(--grid); background:var(--panel);
      display:flex; flex-direction:column; padding:12px; gap:12px; overflow:auto;
    }
    main{
      grid-column:2; grid-row:2; overflow:auto; padding:12px;
      display:grid; grid-template-rows: 0.8fr 1.2fr; gap:12px;
    }
    .card{
      background:var(--panel); border:1px solid var(--grid);
      border-radius:14px; padding:10px; box-shadow:0 0 0 1px rgba(255,255,255,0.02) inset;
    }
    .card h3{margin:0 0 8px 0; font-size:14px; color:var(--muted); font-weight:600}
    .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
    select, button, input[type="range"]{
      background:var(--chip); color:var(--ink); border:1px solid var(--grid);
      padding:8px 10px; border-radius:10px; outline:none;
    }
    select{min-width:160px}
    button{cursor:pointer}
    button.primary{background:var(--accent); color:#081019; border-color:transparent}
    .small{font-size:12px; color:var(--muted)}
    .stack{display:flex; flex-direction:column; gap:8px}
    .plots{
      display:grid; grid-template-columns: 1fr 1fr; gap:12px; height:100%;
    }
    #globe{height:100%}
    #map{height:85%}
    #timeseries{height:100%}
    .legend-note{color:var(--muted); font-size:12px; margin-top:-4px}
    .spacer{flex:1}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    a, a:visited{color:var(--accent)}
    /* Tabs */
    .tabs{display:flex; gap:8px; align-items:center}
    .tab{padding:6px 10px; border:1px solid var(--grid); border-radius:10px; background:var(--chip); cursor:pointer; color:var(--ink)}
    .tab.active{background:var(--accent); color:#081019; border-color:transparent}
    .page{display:none}
    .page.active{display:block}
    .twocol{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    .control-grid{display:grid; grid-template-columns: repeat(3, 1fr); gap:8px}
    .control-grid label{font-size:12px; color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div class="title">Satellite Density Dashboard</div>
    <div class="row small tabs">
      <button class="tab" id="tab-rms">RMS Error Explorer</button>
      <button class="tab active" id="tab-storm">Storm Time Density Inversion</button>
      <span class="spacer"></span>
      <a href="./POD_Assimilation___AMOS_2025-14.pdf" target="_blank" class="small" style="margin-right:12px;">üìÑ AMOS 2025 Paper (PDF)</a>
      <a href="https://charlesplusc.github.io/" target="_blank" class="small" style="margin-right:12px;">Personal Website</a>
      <span id="status" class="mono">Loading‚Ä¶</span>
    </div>
  </header>

  <div class="page active" id="page-storm">
    <div class="wrap">
    <!-- Controls -->
    <aside>
      <div class="card stack">
        <h3>Playback</h3>
        <div class="row">
          <button id="play" class="primary">‚ñ∂Ô∏é Play</button>
          <button id="pause">‚è∏Ô∏é Pause</button>
          <div class="spacer"></div>
          <label class="small">Speed</label>
          <select id="speed">
            <option selected>1000x</option><option>10000x</option><option>100000x</option>
          </select>
        </div>
        <input id="slider" type="range" min="0" max="1" step="1" value="0"/>
        <div class="row small">
          <span>Time:</span><span id="tlabel" class="mono">‚Äî</span>
        </div>
      </div>

      <div class="card stack">
        <h3>Models & Satellites</h3>
        <div class="row">
          <label class="small">Time Series 1</label>
          <select id="modelA"></select>
        </div>
        <div class="row">
          <label class="small">Time Series 2</label>
          <select id="modelB"></select>
        </div>
        <div class="row">
          <label class="small"># Sats</label>
          <select id="satCount">
            <option>1</option><option>2</option><option>3</option>
            <option>6</option><option>9</option><option selected>18</option>
          </select>
        </div>
        <div class="legend-note">
          Density lines use per-satellite colors; bold lines show means.
        </div>
      </div>

      <div class="card stack">
        <h3>Notes</h3>
        <div class="small">
          This dashboard displays the storm time density inversion results from the paper. The visualization demonstrates how POD density retrievals perform during the April 2023 storm, comparing different POD noise levels (Low, Medium, High) and their assimilated counterparts. The think blue series represents densities from one configuration, while the light red series represents another. The thick lines of the same colour are the mean of those thin lines. For more details see the full paper.
        </div>
      </div>
    </aside>

    <!-- Plots -->
    <main>
      <div class="plots">
        <div class="card"><h3>Inertial View (colour = Density Time Series 1)</h3><div id="globe"></div></div>
        <div class="card"><h3>Lat / Lon Tracks</h3><div id="map"></div></div>
      </div>
      <div class="card">
        <h3>Density and SWx Indices Time Series</h3>
        <div id="timeseries"></div>
      </div>
    </main>
    </div>
  </div>

  <div class="page" id="page-rms">
    <div class="wrap">
      <aside>
        <div class="card stack">
          <h2 id="rms_title">RMS Error Predictor</h2>
          <p class="small" style="margin:4px 0 0 0;opacity:0.9">POD noise tiers (3D RMS): Low ‚âà 0.30 m ¬∑ Medium ‚âà 0.458 m ¬∑ High ‚âà 1.80 m</p>
        </div>
        <div class="card stack">
          <h3>Panel A</h3>
          <div class="control-grid">
            <div>
              <label>Noise Level</label>
              <select id="rmsA_tier">
                <option value="high">High (1.8m)</option>
                <option value="medium">Medium (0.458m)</option>
                <option value="low">Low (0.3m)</option>
              </select>
            </div>
            <div>
              <label>AMR (m¬≤/kg)</label>
              <input id="rmsA_amr" type="number" min="0" max="1" step="0.0001" value="0.005"/>
            </div>
            <div>
              <label>Altitude (km)</label>
              <input id="rmsA_alt" type="number" min="300" max="700" step="1" value="630"/>
            </div>
            <div>
              <label>F10.7 (sfu)</label>
              <input id="rmsA_f107" type="number" min="60" max="300" step="1" value="100"/>
            </div>
            <div>
              <label>Ap</label>
              <input id="rmsA_ap" type="number" min="0" max="400" step="1" value="10"/>
            </div>
          </div>
        </div>
        <div class="card stack">
          <h3>Panel B</h3>
          <div class="control-grid">
            <div>
              <label>Noise Level</label>
              <select id="rmsB_tier">
                <option value="high" selected>High (1.8m)</option>
                <option value="medium">Medium (0.458m)</option>
                <option value="low">Low (0.3m)</option>
              </select>
            </div>
            <div>
              <label>AMR (m¬≤/kg)</label>
              <input id="rmsB_amr" type="number" min="0" max="1" step="0.0001" value="0.005"/>
            </div>
            <div>
              <label>Altitude (km)</label>
              <input id="rmsB_alt" type="number" min="300" max="700" step="1" value="550"/>
            </div>
            <div>
              <label>F10.7 (sfu)</label>
              <input id="rmsB_f107" type="number" min="60" max="300" step="1" value="100"/>
            </div>
            <div>
              <label>Ap</label>
              <input id="rmsB_ap" type="number" min="0" max="400" step="1" value="10"/>
            </div>
          </div>
        </div>
        <div class="card stack">
          <div class="small" id="rms_blurb" style="margin-top:0px;opacity:0.85;">
            <p><strong>Disclaimer:</strong> All models are wrong. Some are useful. This tool provides approximations based on simulations. It is in no way a replacement for a full simulation, much less processing of real POD data. It is intended to support discussions and early design processes for density model developers and the satellite operations community.</p>
            
            <p>This tool provides estimates of the expected RMS density retrieval error (RMS% err.) achieved using the Energy Dissipation Rate method as a function of satellite count and fit-span used (number of integer orbits over which the energy is measured), and POD noise level. "Satellite count" refers to the number of equally spaced satellites along a single orbit which are used to resolve a single orbit-averaged density. Density values are taken from the MSIS-00 model, using the selected F10.7 and Ap values to give the globally averaged density at the chosen altitude.</p>

            <p>Error maps show the expected median retrieval error under those conditions based on the experiments presented in the paper. The default area-to-mass ratio is 0.005 (equivalent to Starlink 'open-book' configuration).</p>
            
            <p><strong>Reference AMRs:</strong> GRACE-FO ‚âà0.002, Starlink 'shark-fin' ‚âà0.05, GOCE ‚âà0.0008, and 3U CubeSat ‚âà0.02.</p>
          </div>
        </div>
      </aside>
      <main>
        <div class="card">
          <h3>RMS % Error vs Fit-span and #Sats ‚Äî Panel A</h3>
          <div id="rms_plot_A" style="height:48vh; width:100%"></div>
        </div>
        <div class="card">
          <h3>RMS % Error vs Fit-span and #Sats ‚Äî Panel B</h3>
          <div id="rms_plot_B" style="height:48vh; width:100%"></div>
        </div>
      </main>
    </div>
  </div>

  <script>
  (async function(){
    /* ---------- Utilities ---------- */
    const $ = (id)=>document.getElementById(id);
    const status = $('status');

    // Tabs logic
    const tabStorm = $('tab-storm');
    const tabRms = $('tab-rms');
    const pageStorm = $('page-storm');
    const pageRms = $('page-rms');
    function activateTab(which){
      if(which==='storm'){
        tabStorm.classList.add('active'); tabRms.classList.remove('active');
        pageStorm.classList.add('active'); pageRms.classList.remove('active');
      } else {
        tabRms.classList.add('active'); tabStorm.classList.remove('active');
        pageRms.classList.add('active'); pageStorm.classList.remove('active');
      }
    }
    tabStorm.onclick = ()=>activateTab('storm');
    tabRms.onclick = ()=>activateTab('rms');

    // Color helpers
    const viridis = ['#440154','#482878','#3e4989','#31688e','#26828e','#1f9e89','#35b779','#6ece58','#b5de2b','#fde725'];
    function colorRamp(n, i){
      if(n<=1) return viridis[6];
      const idx = Math.round(i*(viridis.length-1)/(n-1));
      return viridis[Math.max(0,Math.min(viridis.length-1,idx))];
    }

    // log-scale Turbo-like simple ramp for markers (compact)
    function turbo(v, vmin, vmax){
      const t = Math.max(0, Math.min(1, (Math.log10(Math.max(v,1e-20)) - Math.log10(Math.max(vmin,1e-20))) /
                                      (Math.log10(Math.max(vmax,1e-19)) - Math.log10(Math.max(vmin,1e-20)))));
      const stops=[[34,136,234],[84,233,242],[120,255,104],[255,233,84],[255,140,54],[220,38,127]];
      const k = Math.min(stops.length-2, Math.floor(t*(stops.length-1)));
      const f = t*(stops.length-1)-k;
      const c = stops[k].map((v,j)=>Math.round(v + f*(stops[k+1][j]-v)));
      return `rgb(${c[0]},${c[1]},${c[2]})`;
    }

    // Unified palette for time series groups
    const COLOR_A_BASE = 'rgba(80,160,255,0.35)';   // blue translucent for series A per-sat
    const MEAN_A_COLOR = '#2b6cb0';                 // solid blue for series A mean
    const COLOR_B_BASE = 'rgba(255,100,100,0.28)';  // red translucent for series B per-sat
    const MEAN_B_COLOR = '#c53030';                 // solid red for series B mean
    const HASDM_COLOR  = '#e6e6e6';                 // neutral for HASDM model

    // Custom NIPY_SPECTRAL-like colorscale for better low‚Äìmid contrast
    const NIPY_SPECTRAL = [
      [0.00, '#000000'],
      [0.05, '#00035b'],
      [0.10, '#0000ff'],
      [0.20, '#00b5ff'],
      [0.35, '#00ff6f'],
      [0.50, '#aaff00'],
      [0.65, '#f7ff00'],
      [0.80, '#ff6f00'],
      [0.90, '#ff0000'],
      [1.00, '#ffffff']
    ];

    // ---- MSIS precomputed LUT (docs/msis_lut.json) ----
    // Shape: rho[alt][f107][ap], with grids in MSIS_LUT.grid.{alt_km,f107,ap}
    let MSIS_LUT = null;

    async function loadMSISLUT(){
      try{
        const resp = await fetch('./msis_lut.json?v=' + Date.now(), {cache:'no-store'});
        if(!resp.ok) throw new Error('HTTP '+resp.status);
        const lut = await resp.json();
        // Basic shape checks
        if(lut && lut.grid && Array.isArray(lut.grid.alt_km) && Array.isArray(lut.grid.f107) && Array.isArray(lut.grid.ap) && Array.isArray(lut.rho)){
          MSIS_LUT = lut;
          console.log('Loaded MSIS LUT:', {alts: lut.grid.alt_km.length, f107: lut.grid.f107.length, ap: lut.grid.ap.length});
        }
      }catch(e){
        console.warn('MSIS LUT not found; RMS page disabled.', e);
        MSIS_LUT = null;
        status.textContent = '‚ö†Ô∏è MSIS LUT missing ‚Äî RMS page disabled';
      }
    }

    // Locate bracketing indices and linear weights for 1D array (monotonic ascending)
    function bracketIdxW(arr, x){
      const n = arr.length;
      if(x <= arr[0]) return {i0:0, i1:0, w:0};
      if(x >= arr[n-1]) return {i0:n-1, i1:n-1, w:0};
      let lo = 0, hi = n-1;
      while(hi - lo > 1){
        const mid = (lo + hi) >> 1;
        if(arr[mid] <= x) lo = mid; else hi = mid;
      }
      const i0 = lo, i1 = hi;
      const w = (x - arr[i0]) / (arr[i1] - arr[i0]);
      return {i0, i1, w};
    }

    // Trilinear interpolation over rho[alt][f107][ap]
    function rho_from_LUT(alt_km, f107, ap){
      if(!MSIS_LUT) return null;
      const A = MSIS_LUT.grid.alt_km, F = MSIS_LUT.grid.f107, P = MSIS_LUT.grid.ap;
      const R = MSIS_LUT.rho;
      const {i0:a0, i1:a1, w:wa} = bracketIdxW(A, alt_km);
      const {i0:f0, i1:f1, w:wf} = bracketIdxW(F, f107);
      const {i0:p0, i1:p1, w:wp} = bracketIdxW(P, ap);
      const c000=R[a0][f0][p0], c100=R[a1][f0][p0], c010=R[a0][f1][p0], c110=R[a1][f1][p0];
      const c001=R[a0][f0][p1], c101=R[a1][f0][p1], c011=R[a0][f1][p1], c111=R[a1][f1][p1];
      const c00=c000*(1-wa)+c100*wa, c01=c001*(1-wa)+c101*wa, c10=c010*(1-wa)+c110*wa, c11=c011*(1-wa)+c111*wa;
      const c0=c00*(1-wf)+c10*wf, c1=c01*(1-wf)+c11*wf;
      const c=c0*(1-wp)+c1*wp;
      return (Number.isFinite(c) && c>0) ? c : null;
    }

    // --- RMS model constants  ---
    const E_MAX = 97.0, E_MIN = 1.8, D50 = 2.1e-7, KAPPA = 1.12;
    const B_UNASSIM = 0.6;
    const CAL = {
      high:   {alpha: 0.8433088828715762, beta: -0.32224430545188654},
      medium: {alpha: 0.21070487695101514, beta: -1.433357778151463},
      low:    {alpha: 0.10466223404590143, beta: -1.591827565464284}
    };

    function rho_kg_m3_from_f107_ap(alt_km, f107, ap){
      const rhoLUT = rho_from_LUT(alt_km, f107, ap);
      if(rhoLUT === null){
        throw new Error('MSIS LUT not loaded or query out of bounds');
      }
      return rhoLUT;
    }
    const RE = 6371e3, MU = 3.986004418e14, CD = 2.2;
    function orbitalSpeed(alt_km){ const r = RE + alt_km*1e3; return Math.sqrt(MU/r); }
    function dragAccel(rho, amr, v){ return 0.5 * CD * amr * rho * v*v; }
    function fmtSI(x){
      if(!Number.isFinite(x) || x===0) return '0';
      const e = Math.floor(Math.log10(Math.abs(x)));
      const m = x / Math.pow(10, e);
      return `${m.toFixed(3)}e${e}`;
    }

    function error_surface_js(d, f, N, b){
      const L_above = (E_MAX - E_MIN) / (1.0 + Math.pow(d/D50, KAPPA));
      return E_MIN + L_above * Math.pow(2, -(f-1)) * Math.pow(N, -b);
    }
    function calibrated_error_surface_js(d, f, N, tier){
      // Notebook parity: use fixed exponent on N and apply per-tier (alpha, beta)
      // 1) Compute base surface with unassimilated exponent b=0.6
      const base = error_surface_js(d, f, N, B_UNASSIM);
      // 2) Apply per-tier linear calibration to the above-floor component
      const cal = CAL[tier] || CAL.medium; // {alpha, beta}
      const E = E_MIN + cal.alpha * (base - E_MIN) + cal.beta;
      // 3) Clamp to [E_MIN, E_MAX]
      return Math.max(E_MIN, Math.min(E_MAX, E));
    }

    function makeHeatData(tier, amr, alt_km, f107, ap, fMax=5, nMax=20){
      const rho = rho_kg_m3_from_f107_ap(alt_km, f107, ap);
      const v   = orbitalSpeed(alt_km);
      const d   = dragAccel(rho, amr, v);
      const xF = Array.from({length:Math.min(5, fMax||5)}, (_,i)=>i+1);
      const yN = Array.from({length:Math.min(20,nMax||20)},(_,i)=>i+1);
      const z  = yN.map(N=> xF.map(f=> calibrated_error_surface_js(d, f, N, tier)) );
      return {x:xF, y:yN, z};
    }

    function renderHeatmap(elId, hdr, data, zmin, zmax){
      // Nice, continuous look
      const heat = {
        type:'heatmap', x:data.x, y:data.y, z:data.z,
        colorscale: NIPY_SPECTRAL,
        zmin:zmin, zmax:zmax, zauto:false,
        zsmooth:'best',
        colorbar:{
          title:'RMS %',
          thickness:14,
          len:0.9,
          tickmode:'array',
          tickvals: buildColorbarTicks(zmin, zmax),
          ticktext: buildColorbarTicks(zmin, zmax).map(v=>String(v))
        }
      };

      // Overlay isolines at 5%, 10%, 20%
      const isoLevels = [5, 10, 20].filter(L => L>=zmin && L<=zmax);
      const isoTraces = isoLevels.map(L=>({
        type:'contour', x:data.x, y:data.y, z:data.z,
        contours:{start:L, end:L, size:1, coloring:'lines', showlabels:true, labelfont:{color:'#eeeeee', size:10}},
        line:{color:'#ffffff', width:1.5},
        showscale:false,
        hoverinfo:'skip'
      }));

      const layout = {
        autosize:true,
        margin:{t:30,l:60,r:10,b:40},
        paper_bgcolor:'rgba(0,0,0,0)',
        plot_bgcolor:'rgba(0,0,0,0)',
        font:{color:var_ink()},
        xaxis:{title:'Fit-span (orbits)', dtick:1, range:[1,5]},
        yaxis:{
          title:'# Satellites', 
          type:'log', 
          range:[Math.log10(1), Math.log10(20)], 
          tickmode:'array',
          tickvals:[1, 2, 5, 10, 20],
          ticktext:['1', '2', '5', '10', '20']
        },
        title: hdr
      };

      Plotly.react(elId, [heat, ...isoTraces], layout, {displaylogo:false, responsive:true});
    }

    function buildColorbarTicks(zmin, zmax){
      // Build ticks at nice round numbers and ensure inclusion of 5,10,20 if they lie in range
      const candidates = [0,2,5,10,15,20,30,40,50,60,80,100];
      const ticks = candidates.filter(v => v>=Math.floor(zmin) && v<=Math.ceil(zmax));
      if(!ticks.length){
        const mid = (zmin+zmax)/2;
        return [Math.round(zmin), Math.round(mid), Math.round(zmax)];
      }
      // Ensure uniqueness and sorted
      return Array.from(new Set(ticks)).sort((a,b)=>a-b);
    }
    function var_ink(){ return getComputedStyle(document.documentElement).getPropertyValue('--ink') || '#eee'; }

    // Number of recent steps to show on lat/lon tracks
    const TAIL_STEPS = 10;

    /* ---------- Load data ---------- */
    // Load data with friendly error if opened via file://
    status.textContent = 'Loading data‚Ä¶';
    const cacheBuster = `?v=${Date.now()}`; // avoid CDN/browser caching on updates
    let dash;
    try {
      const resp = await fetch(`./dashboard_data.json${cacheBuster}`);
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
      }
      dash = await resp.json();
      status.textContent = 'Preparing‚Ä¶';
      // Attempt to load MSIS LUT in parallel (used by RMS tab)
      await loadMSISLUT();
      if(MSIS_LUT){ status.textContent = 'Preparing‚Ä¶ (MSIS LUT loaded)'; }
    } catch (err) {
      console.error('Failed to load dashboard_data.json', err);
      status.textContent = '‚ö†Ô∏è Could not load data. If you opened this file directly (file://), please serve docs/ over http(s) ‚Äî e.g., `python -m http.server -d docs 8000` then visit http://localhost:8000/';
      return;
    }

    const combos = dash.combos || {};
    const models = dash.densities_by_model || { commercial: dash.densities };
    const modelKeys = Object.keys(models);
    const satsAll = (()=>{
      const any = models[modelKeys[0]] || {};
      return Object.keys(any).filter(k=>!['times','model','mean'].includes(k));
    })();
    const trajArr = dash.trajectories || [];
    const kpArr = dash.kp || [];
    const dstArr = dash.dst || [];

    // Populate selectors
    const modelA = $('modelA'), modelB = $('modelB');
    modelKeys.forEach(k=>{
      console.log('Model key:', k); // Debug: see what the actual keys are
      let label;
      // Create custom labels for different model types
      const lowerK = k.toLowerCase();
      if(lowerK.includes('commercial') && !lowerK.includes('assimilated')) label = 'High (1.8m)';
      else if(lowerK.includes('medium') && !lowerK.includes('assimilated')) label = 'Medium (0.458m)';
      else if(lowerK.includes('low') && !lowerK.includes('assimilated')) label = 'Low (0.3m)';
      else if(lowerK.includes('commercial') && lowerK.includes('assimilated')) label = 'High (assimilated)';
      else if(lowerK.includes('medium') && lowerK.includes('assimilated')) label = 'Medium (assimilated)';
      else if(lowerK.includes('low') && lowerK.includes('assimilated')) label = 'Low (assimilated)';
      else {
        // Fallback to original logic for any other keys
        label = k.replace(/_/g,' ').replace(/\b\w/g, s=>s.toUpperCase());
      }
      
      const o1 = document.createElement('option'); o1.value=k; o1.textContent=label; modelA.appendChild(o1);
      const o2 = document.createElement('option'); o2.value=k; o2.textContent=label; modelB.appendChild(o2);
    });
    // Default A: first key; Default B: none (empty option)
    const noneOpt = document.createElement('option'); noneOpt.value=''; noneOpt.textContent='None';
    modelB.insertBefore(noneOpt, modelB.firstChild);
    modelA.value = modelKeys.includes('commercial') ? 'commercial' : modelKeys[0];
    modelB.value = '';

    const satCountSel = $('satCount');
    let satCount = parseInt(satCountSel.value,10);

    // Time axis
    function parseTimes(arr){ return arr.map(t=>new Date(t)); }
    function getModel(key){
      if(!key) return null;
      const raw = models[key];
      if(!raw) return null;
      // For assimilated variants, multiply satellite series by 2.2 (missing scale factor)
      if(/^assimilated/i.test(key)){
        const out = { times: raw.times, model: raw.model };
        Object.keys(raw).forEach(k=>{
          if(!['times','model','mean'].includes(k)){
            // scale per-satellite series only
            out[k] = (raw[k] || []).map(v => v / 2.2);
          }
        });
        return out;
      }
      // Non-assimilated: return as-is
      return raw;
    }

    /* ---------- Shared time base ---------- */
    let modelAData = getModel(modelA.value);
    const timesAll = parseTimes(modelAData.times);
    const tMin = timesAll[0], tMax = timesAll[timesAll.length-1];

    // Slider time base derived from trajectories length if present, otherwise density times
    const nSteps = (trajArr[0] && trajArr[0].path) ? trajArr[0].path.length : timesAll.length;
    const trajStart = timesAll[0] || new Date();
    const trajTimes = Array.from({length:nSteps},(_,i)=> new Date(trajStart.getTime()+i*60*1000)); // 60s step fallback

    // Map helper
    const satIndex = Object.fromEntries(trajArr.map((s,i)=>[s.name, i]));

    // Active satellites by count using combos
    function activeSatNames(){
      const c = combos[String(satCount)] || combos[satCount] || [];
      return c.filter(n=>satsAll.includes(n));
    }

    // Mean helper
    function sliceToIdx(arr, idx){ return arr.slice(0, Math.max(1, idx+1)); }
    function meanSeries(dobj, names){
      const n = names.length, L = dobj.times.length;
      const out = new Array(L);
      for(let t=0;t<L;t++){
        let s = 0;
        for(const nm of names){ s += (dobj[nm]?.[t] ?? 0); }
        out[t] = s / Math.max(1,n);
      }
      return out;
    }

    // Index series to current time
    const kpTimes = kpArr.map(d=>new Date(d.datetime));
    const kpVals  = kpArr.map(d=>d.kp);
    const dstTimes= dstArr.map(d=>new Date(d.datetime));
    const dstVals = dstArr.map(d=>d.dst);

    /* ---------- Build plots ---------- */

    // 1) Inertial view (clean sphere + markers)
    (function initGlobe(){
      const R = 6378137; // meters
      const phi = [], th = [];
      for(let i=0;i<40;i++) phi.push(i*Math.PI/39);
      for(let j=0;j<80;j++) th.push(j*2*Math.PI/79);
      const xs = phi.map(p=>th.map(t=>R*Math.cos(t)*Math.sin(p)));
      const ys = phi.map(p=>th.map(t=>R*Math.sin(t)*Math.sin(p)));
      const zs = phi.map(p=>th.map(t=>R*Math.cos(p)));

      const earth = {
        type:'surface', x:xs, y:ys, z:zs, showscale:false, opacity:0.12,
        colorscale:[[0,'#6ab7ff'],[1,'#6ab7ff']], hoverinfo:'skip'
      };

      // Satellite marker traces (one per active sat). Start with placeholders; update via restyle.
      const names = activeSatNames();
      const markers = names.map((nm,i)=>({
        type:'scatter3d', mode:'markers',
        x:[0], y:[0], z:[0],
        marker:{size:5, color:viridis[i%viridis.length]},
        name:nm, showlegend:false, hoverinfo:'skip'
      }));

      // Add a dummy colorbar trace for density legend - match the custom turbo colorscale
      const turboColorscale = [
        [0.0, 'rgb(34,136,234)'],   // Blue
        [0.2, 'rgb(84,233,242)'],   // Cyan
        [0.4, 'rgb(120,255,104)'],  // Green
        [0.6, 'rgb(255,233,84)'],   // Yellow
        [0.8, 'rgb(255,140,54)'],   // Orange
        [1.0, 'rgb(220,38,127)']    // Purple/Pink
      ];
      
      const colorbar = {
        type:'scatter3d', mode:'markers',
        x:[0], y:[0], z:[0], // invisible position
        marker:{
          size:0.1, // tiny invisible markers
          // Use log values to match the turbo() function's log scaling
          color:[Math.log10(0.7e-13), Math.log10(8e-13)], 
          colorscale:turboColorscale,
          showscale:true,
          colorbar:{
            title:{text:'Density (kg/m¬≥)', font:{size:12, color:'#e7e9ee'}},
            thickness:15,
            len:0.7,
            x:1.02,
            tickmode:'array',
            tickvals:[Math.log10(1e-13), Math.log10(2e-13), Math.log10(4e-13), Math.log10(8e-13)],
            ticktext:['1e-13', '2e-13', '4e-13', '8e-13'],
            tickfont:{size:10, color:'#e7e9ee'}
          }
        },
        showlegend:false, hoverinfo:'skip'
      };

      const layout = {
        scene:{
          xaxis:{visible:false}, yaxis:{visible:false}, zaxis:{visible:false},
          aspectmode:'data', bgcolor:'rgba(0,0,0,0)'
        },
        margin:{t:0,l:0,r:30,b:0},
        paper_bgcolor:'rgba(0,0,0,0)',
        plot_bgcolor:'rgba(0,0,0,0)'
      };
      Plotly.newPlot('globe', [earth, ...markers, colorbar], layout, {displaylogo:false, responsive:true});
    })();

    // 2) Lat/Lon map (tracks + current markers)
    function makeMapTraces(step){
      const names = activeSatNames();
      const traces = [];
      names.forEach((nm,i)=>{
        const idx = satIndex[nm];
        if(idx===undefined) return;
        const lla = trajArr[idx].latlonalt || [];
        const lon = lla.map(p=>p[1]);
        const lat = lla.map(p=>p[0]);

        // Track (line): only show last TAIL_STEPS
        const startIdx = Math.max(0, step - (TAIL_STEPS - 1));
        traces.push({
          type:'scattergeo', mode:'lines',
          lon: lon.slice(startIdx, step + 1),
          lat: lat.slice(startIdx, step + 1),
          line:{width:1, color: colorRamp(names.length, i)},
          name: nm, showlegend:false, hoverinfo:'skip'
        });
        // Current marker
        if(lla[step]){
          traces.push({
            type:'scattergeo', mode:'markers',
            lon:[lla[step][1]], lat:[lla[step][0]],
            marker:{size:6, color: colorRamp(names.length, i)},
            name: nm, showlegend:false, hovertemplate: `${nm}<extra></extra>`
          });
        }
      });
      return traces;
    }
    (function initMap(){
      const layout = {
        geo:{
          projection:{type:'natural earth'},
          showland:true, landcolor:'#1e2533',
          showcountries:true, countrycolor:'#47506a',
          showocean:true, oceancolor:'#0e3954',
          lataxis:{range:[-80,80]}, lonaxis:{range:[-180,180]},
          bgcolor:'rgba(0,0,0,0)'
        },
        margin:{t:10,l:0,r:0,b:0},
        paper_bgcolor:'rgba(0,0,0,0)',
        plot_bgcolor:'rgba(0,0,0,0)'
      };
      Plotly.newPlot('map', makeMapTraces(0), layout, {displaylogo:false, responsive:true});
    })();

    // 3) Time series (3 rows: Density, Dst, Kp step)
    function makeTimeseries(step){
      const names = activeSatNames();

      const A = getModel(modelA.value);
      const B = getModel(modelB.value);
      const times = A ? parseTimes(A.times) : [];

      // index into density times using current traj time
      const ct = trajTimes[step];
      let k=0; while(times.length && k<times.length-1 && ct>=times[k+1]) k++;

      const traces = [];

      // --- HASDM model line (from series A's model) ---
      if (A && Array.isArray(A.model)){
        traces.push({
          x: sliceToIdx(times,k), y: sliceToIdx(A.model,k),
          mode:'lines', name:'HASDM',
          line:{width:2, color: HASDM_COLOR},
          hovertemplate:'HASDM: %{y:.2e}<extra></extra>',
          xaxis:'x', yaxis:'y1'
        });
      }

      // --- Per-satellite lines for A (unified blue, translucent) ---
      if (A){
        names.forEach((nm)=>{
          if(!A[nm]) return;
          traces.push({
            x: sliceToIdx(times,k), y: sliceToIdx(A[nm],k),
            mode:'lines', name: nm, showlegend:false,
            line:{width:1.2, color: COLOR_A_BASE},
            hovertemplate:`${nm}: %{y:.2e}<extra></extra>`,
            xaxis:'x', yaxis:'y1'
          });
        });
        // Mean A (bold, darker blue)
        const meanA = meanSeries(A, names);
        traces.push({
          x: sliceToIdx(times,k), y: sliceToIdx(meanA,k),
          mode:'lines', name:'Mean (A)',
          line:{width:3, color: MEAN_A_COLOR},
          hovertemplate:'Mean (A): %{y:.2e}<extra></extra>',
          xaxis:'x', yaxis:'y1'
        });
      }

      // --- Per-satellite lines for B (optional, unified red) ---
      if (B){
        const timesB = parseTimes(B.times);
        let kb=0; while(timesB.length && kb<timesB.length-1 && ct>=timesB[kb+1]) kb++;
        names.forEach((nm)=>{
          if(!B[nm]) return;
          traces.push({
            x: sliceToIdx(timesB,kb), y: sliceToIdx(B[nm],kb),
            mode:'lines', name: nm+' (B)', showlegend:false,
            line:{width:1.2, color: COLOR_B_BASE},
            hovertemplate:`${nm} (B): %{y:.2e}<extra></extra>`,
            xaxis:'x', yaxis:'y1'
          });
        });
        const meanB = meanSeries(B, names);
        traces.push({
          x: sliceToIdx(timesB,kb), y: sliceToIdx(meanB,kb),
          mode:'lines', name:'Mean (B)',
          line:{width:3, color: MEAN_B_COLOR},
          hovertemplate:'Mean (B): %{y:.2e}<extra></extra>',
          xaxis:'x', yaxis:'y1'
        });
      }

      // --- Dst ---
      let kd=0; while(kd<dstTimes.length-1 && ct>=dstTimes[kd+1]) kd++;
      const dstTrace = {
        x: sliceToIdx(dstTimes,kd), y: sliceToIdx(dstVals,kd),
        mode:'lines+markers', name:'Dst', line:{width:2, color:'#7bd88f'},
        marker:{size:4}, xaxis:'x', yaxis:'y2', hovertemplate:'Dst: %{y}<extra></extra>'
      };

      // --- Kp (step-like) ---
      let kk=0; while(kk<kpTimes.length-1 && ct>=kpTimes[kk+1]) kk++;
      const kpTrace = {
        x: sliceToIdx(kpTimes,kk), y: sliceToIdx(kpVals,kk),
        mode:'lines', name:'Kp', line:{width:2, color:'#ffb86b', shape:'hv'},
        xaxis:'x', yaxis:'y3', hovertemplate:'Kp: %{y}<extra></extra>'
      };

      const layout = {
        grid:{rows:3, columns:1, pattern:'independent', roworder:'top to bottom'},
        xaxis:{
          title:'Time', type:'date', tickformat:'%b %d\n%H:%M', anchor:'y3', domain:[0,1],
          range:['2023-04-21T00:00:00Z','2023-04-28T00:00:00Z']
        },
        yaxis:{title:'Density (kg/m¬≥)', tickformat:'.2e', domain:[0.56,1], range:[0, 8e-13], autorange:false},
        yaxis2:{title:'Dst (nT)', domain:[0.28,0.56]},
        yaxis3:{title:'Kp', dtick:3, domain:[0,0.28]},
        legend:{orientation:'h', y:-0.18, font:{color:'#d5d9e5'}},
        margin:{t:10,l:80,r:20,b:70},
        paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
        font:{color:'#e7e9ee'}, hovermode:'x unified'
      };

      Plotly.react('timeseries', [...traces, dstTrace, kpTrace], layout, {displaylogo:false, responsive:true});
    }

    // Initial render
    makeTimeseries(0);

    // Position updates (globe & map) + time label
    const densMin = 0.7e-13, densMax = 8e-13;
    function updateScene(step){
      // time label
      $('tlabel').textContent = trajTimes[step].toISOString().replace('T',' ').slice(0,19);

      // Globe: update satellite markers
      const names = activeSatNames();
      const updates = {x:[], y:[], z:[], 'marker.color':[]};
      const A = getModel(modelA.value);
      const times = parseTimes(A.times);
      // find density index for current time
      const ct = trajTimes[step];
      let k=0; while(k<times.length-1 && ct>=times[k+1]) k++;

      names.forEach((nm)=>{
        const i = satIndex[nm]; if(i===undefined) return;
        const pos = (trajArr[i].path?.[step]) || [0,0,0];
        updates.x.push([pos[0]]);
        updates.y.push([pos[1]]);
        updates.z.push([pos[2]]);
        const val = (A[nm]?.[k]) ?? 1e-13;
        updates['marker.color'].push([turbo(val, densMin, densMax)]);
      });
      // traces: 0 is earth surface, markers start at 1
      const idxs = Array.from({length:names.length},(_,j)=>1+j);
      Plotly.restyle('globe', updates, idxs);

      // Map
      Plotly.react('map', makeMapTraces(step), {
        geo:{
          projection:{type:'natural earth'}, showland:true, landcolor:'#1e2533',
          showcountries:true, countrycolor:'#47506a', showocean:true, oceancolor:'#0e3954',
          lataxis:{range:[-80,80]}, lonaxis:{range:[-180,180]}, bgcolor:'rgba(0,0,0,0)'
        },
        margin:{t:10,l:0,r:0,b:0}, paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)'
      }, {displaylogo:false, responsive:true});

      // Time series to current time
      makeTimeseries(step);
    }

    /* ---------- Controls ---------- */
    const slider = $('slider'); slider.max = String(nSteps-1); slider.value = '0';

    let playing = false, timer = null;
    function getSpeedParams(){
      const s = $('speed').value;
      const mult = parseInt(s.replace('x','')) || 1;
      
      // Use both step size and interval to achieve different speeds
      let stepsPerFrame, intervalMs;
      if(mult <= 1000) {
        stepsPerFrame = 1;
        intervalMs = Math.max(50, 1000 / mult);
      } else if(mult <= 10000) {
        stepsPerFrame = Math.floor(mult / 1000);
        intervalMs = 50;
      } else {
        stepsPerFrame = Math.floor(mult / 1000);
        intervalMs = 20;
      }
      
      console.log('Speed setting:', s, 'Steps per frame:', stepsPerFrame, 'Interval ms:', intervalMs);
      return {stepsPerFrame, intervalMs};
    }

    function playStep(){
      const {stepsPerFrame, intervalMs} = getSpeedParams();
      
      let i = parseInt(slider.value,10);
      // Advance by multiple steps for higher speeds
      i = (i + stepsPerFrame) % nSteps;
      slider.value = String(i);
      updateScene(i);
      
      if(playing) {
        timer = setTimeout(playStep, intervalMs);
      }
    }

    function play(){
      if(playing) return;
      playing = true;
      playStep();
    }
    function pause(){
      playing = false;
      if(timer){ clearTimeout(timer); timer=null; }
    }

    $('play').onclick = ()=>{ pause(); play(); };
    $('pause').onclick = ()=>{ pause(); };
    $('speed').onchange = ()=>{ 
      console.log('Speed changed, was playing:', playing);
      if(playing){ 
        pause(); 
        play(); 
      } 
    };
    slider.oninput = ()=>{ pause(); updateScene(parseInt(slider.value,10)); };

    satCountSel.onchange = ()=>{
      satCount = parseInt(satCountSel.value,10);
      // re-seed globe traces to match new satellite count
      // easiest: rebuild globe with new marker set
      (function resetGlobe(){
        const gd = document.getElementById('globe');
        const data = gd.data || [];
        const earth = data[0]; // keep surface
        const names = activeSatNames();
        const markers = names.map((nm,i)=>({
          type:'scatter3d', mode:'markers',
          x:[0], y:[0], z:[0],
          marker:{size:5, color:colorRamp(names.length,i)},
          name:nm, showlegend:false, hoverinfo:'skip'
        }));
        Plotly.react('globe', [earth, ...markers], gd.layout, {displaylogo:false, responsive:true});
      })();
      updateScene(parseInt(slider.value,10));
    };

    modelA.onchange = ()=>{
      modelAData = getModel(modelA.value);
      updateScene(parseInt(slider.value,10));
    };
    modelB.onchange = ()=>{
      updateScene(parseInt(slider.value,10));
    };

    // --- RMS page wiring ---
    function updateRMS(){
      if(!MSIS_LUT){
        const layoutMsg = {
          annotations:[{text:'MSIS LUT missing ‚Äî ensure docs/msis_lut.json is present and served over HTTP(S).', xref:'paper', yref:'paper', x:0.5, y:0.5, showarrow:false, font:{size:14, color:var_ink()}}],
          paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)', margin:{t:40,l:40,r:40,b:40}
        };
        Plotly.react('rms_plot_A', [], layoutMsg, {displaylogo:false, responsive:true});
        Plotly.react('rms_plot_B', [], layoutMsg, {displaylogo:false, responsive:true});
        return;
      }
      try{
        // Panel A
        const tierA = $('rmsA_tier').value;
        const amrA  = parseFloat($('rmsA_amr').value);
        const altA  = parseFloat($('rmsA_alt').value);
        const fA    = parseFloat($('rmsA_f107').value);
        const apA   = parseFloat($('rmsA_ap').value);
        // Panel B
        const tierB = $('rmsB_tier').value;
        const amrB  = parseFloat($('rmsB_amr').value);
        const altB  = parseFloat($('rmsB_alt').value);
        const fB    = parseFloat($('rmsB_f107').value);
        const apB   = parseFloat($('rmsB_ap').value);

        // Compute densities/drag
        let rhoA, rhoB;
        try{ rhoA = rho_kg_m3_from_f107_ap(altA, fA, apA); }catch(e){ rhoA = NaN; }
        try{ rhoB = rho_kg_m3_from_f107_ap(altB, fB, apB); }catch(e){ rhoB = NaN; }
        const vA = orbitalSpeed(altA), vB = orbitalSpeed(altB);
        const dA = dragAccel(rhoA, amrA, vA);
        const dB = dragAccel(rhoB, amrB, vB);

        const dataA = makeHeatData(tierA, amrA, altA, fA, apA);
        const dataB = makeHeatData(tierB, amrB, altB, fB, apB);

        // Shared color axis across both plots
        const allZ = [...dataA.z.flat(), ...dataB.z.flat()];
        const zmin = Math.min(...allZ);
        const zmax = Math.max(...allZ);

        renderHeatmap(
          'rms_plot_A',
          `POD Noise Level=${tierA} ¬∑ Neutral Density=${fmtSI(rhoA)} kg/m¬≥ ¬∑ Drag acc.=${fmtSI(dA)} m/s¬≤`,
          dataA, zmin, zmax
        );
        renderHeatmap(
          'rms_plot_B',
          `POD Noise Level=${tierB} ¬∑ Neutral Density=${fmtSI(rhoB)} kg/m¬≥ ¬∑ Drag acc.=${fmtSI(dB)} m/s¬≤`,
          dataB, zmin, zmax
        );
      }catch(err){
        console.error(err);
        const layoutMsg = {
          annotations:[{text:'MSIS query failed: '+String(err.message||err), xref:'paper', yref:'paper', x:0.5, y:0.5, showarrow:false, font:{size:14, color:var_ink()}}],
          paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)', margin:{t:40,l:40,r:40,b:40}
        };
        Plotly.react('rms_plot_A', [], layoutMsg, {displaylogo:false, responsive:true});
        Plotly.react('rms_plot_B', [], layoutMsg, {displaylogo:false, responsive:true});
      }
    }

    ['rmsA_tier','rmsA_amr','rmsA_alt','rmsA_f107','rmsA_ap',
     'rmsB_tier','rmsB_amr','rmsB_alt','rmsB_f107','rmsB_ap'].forEach(id=>{
      const el = $(id); if(el){ el.oninput = updateRMS; el.onchange = updateRMS; }
    });

    // First paint
    status.textContent = `Ready ¬∑ ${activeSatNames().length} sats`;
    updateScene(0);
    updateRMS();
  })();
  </script>
</body>
</html>